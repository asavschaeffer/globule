# ADR-0001: Contracts-First and Headless-Core Architecture

**Date**: 2025-08-12
**Status**: Adopted

## Context

The Globule prototype has validated our core concepts, but its architecture is tightly coupled. The business logic, UI, and external service interactions are intertwined, making it difficult to test, maintain, and extend. To evolve Globule into a robust and modular "Cathedral," a significant architectural refactoring is required.

The primary goal is to create a "headless" core engine that is completely decoupled from any specific frontend (TUI, CLI, Web) or backend service provider (Ollama, SQLite).

## Decision

We will adopt a **Contracts-First** design methodology for this refactoring effort. This means we will define the stable interfaces and data structures of our application *before* writing the implementation code. This approach is foundational to achieving a truly headless-core architecture.

Our contracts will be defined as follows:

1.  **Data Contracts**: Immutable Pydantic models will define the core "nouns" of our system (e.g., `GlobuleV1`, `ProcessedGlobuleV1`). These models will be versioned to ensure backward compatibility.
2.  **Service Contracts**: Abstract Base Classes (ABCs) will define the core "verbs" of our system (e.g., `IOrchestrationEngine`, `IParserProvider`). These interfaces will establish the boundaries between the core engine, UI, and external services.

All development will follow a strict, unidirectional dependency flow: `UI` -> `Engine` -> `Adapters` -> `Providers`.

## Consequences

**Positive**:
- **Decoupling**: Enforces separation of concerns, leading to a modular and maintainable codebase.
- **Testability**: Allows for isolated testing of the core business logic without UI or external service dependencies.
- **Extensibility**: New frontends or service providers can be added by simply implementing the required interfaces, without changing the core engine.
- **Clarity**: The contracts serve as clear, enforceable documentation for how components interact.
- **Parallel Development**: Once contracts are defined, teams can work on different components (e.g., UI and a service adapter) in parallel.

**Negative**:
- **Initial Overhead**: Requires more upfront design work to define the contracts before implementation can begin.
- **Boilerplate**: May introduce a small amount of boilerplate code for defining interfaces and models.

This decision is documented in the `PROJECT_CHARTER.md` and will be enforced through code reviews and CI checks.